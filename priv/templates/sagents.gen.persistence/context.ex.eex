defmodule <%= @context_module %> do
  @moduledoc """
  Context for conversation persistence with multi-content type support.

  This module provides scoped access to conversations, agent states, and display messages.

  ## Scope-Based Security

  All conversation operations require a scope struct (`<%= @scope_module %>`)
  as the first argument. This ensures queries are automatically filtered to
  the appropriate user, organization, or team context.

  ## Customization Required

  **IMPORTANT**: The generated code uses generic scope filtering. You must
  customize the query filters to match your scope struct fields:

  ```elixir
  # Example: If your scope has :current_user_id
  defp scope_query(query, %Scope{current_user_id: user_id}) do
    from q in query, where: q.<%= @owner_field %> == ^user_id
  end

  # Example: If your scope has :organization_id (multi-tenant)
  defp scope_query(query, %Scope{organization_id: org_id}) do
    from q in query, where: q.organization_id == ^org_id
  end
  ```

  Update `scope_query/2` and related functions based on YOUR scope structure.

  ## Multi-Content Type Support

  Display messages support multiple content types (text, thinking, images, files, etc.).
  Use the provided helper functions to create messages with proper structure:

  - `append_text_message/3` - Standard text content
  - `append_thinking_message/2` - AI reasoning blocks
  - `append_image_message/3` - Images with URL or base64 data
  - `append_file_message/4` - File references
  - `append_structured_data_message/4` - Tables, JSON, etc.
  - `append_notification_message/3` - System notifications
  - `append_error_message/3` - Error messages

  **IMPORTANT**: All content keys are strings (not atoms) due to JSONB storage.
  """

  import Ecto.Query, warn: false
  alias <%= @repo %>
  alias <%= @context_module %>.AgentState
  alias <%= @context_module %>.Conversation
  alias <%= @context_module %>.DisplayMessage
  alias <%= @scope_module %>, as: Scope

  #
  # Conversation CRUD
  #

  @doc """
  Creates a conversation within the given scope.

  The conversation is automatically associated with the scope's owner.
  Accepts attrs with either atom or string keys.
  """
  def create_conversation(%Scope{} = scope, attrs) do
    scope
    |> get_owner_id()
    |> Conversation.create_changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Gets a conversation by ID, scoped to the given context.

  Raises if the conversation doesn't exist or doesn't belong to the scope.
  """
  def get_conversation!(%Scope{} = scope, id) do
    Conversation
    |> scope_query(scope)
    |> Repo.get!(id)
  end

  @doc """
  Lists all conversations accessible within the given scope.

  ## Options

    * `:limit` - Maximum number of conversations to return (default: 50)
    * `:offset` - Number of conversations to skip (default: 0)
  """
  def list_conversations(%Scope{} = scope, opts \\ []) do
    limit = Keyword.get(opts, :limit, 50)
    offset = Keyword.get(opts, :offset, 0)

    Conversation
    |> scope_query(scope)
    |> order_by([c], desc: c.updated_at)
    |> limit(^limit)
    |> offset(^offset)
    |> Repo.all()
  end

  def update_conversation(%Conversation{} = conversation, attrs) do
    conversation
    |> Conversation.changeset(attrs)
    |> Repo.update()
  end

  def delete_conversation(%Conversation{} = conversation) do
    Repo.delete(conversation)
  end

  #
  # Agent State Persistence
  #

  def save_agent_state(conversation_id, state) do
    attrs = %{
      conversation_id: conversation_id,
      state_data: state,
      version: state["version"] || 1
    }

    case get_agent_state(conversation_id) do
      nil ->
        %AgentState{}
        |> AgentState.changeset(attrs)
        |> Repo.insert()

      existing ->
        existing
        |> AgentState.changeset(attrs)
        |> Repo.update()
    end
  end

  def load_agent_state(conversation_id) do
    case get_agent_state(conversation_id) do
      nil -> {:error, :not_found}
      state -> {:ok, state.state_data}
    end
  end

  defp get_agent_state(conversation_id) do
    AgentState
    |> where([a], a.conversation_id == ^conversation_id)
    |> Repo.one()
  end

  #
  # Display Messages
  #

  @doc """
  Appends a display message to the conversation.

  The message should be a map with keys:
  - `message_type` - "user", "assistant", "tool", "system"
  - `content_type` - Type of content for rendering
  - `content` - Map with structure based on content_type
  - `metadata` - Optional metadata

  For easier usage, consider using the content-type-specific helper functions.
  """
  def append_display_message(conversation_id, attrs) do
    conversation_id
    |> DisplayMessage.create_changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Loads all display messages for a conversation.

  ## Options

    * `:limit` - Maximum number of messages to return (default: 100)
    * `:offset` - Number of messages to skip (default: 0)
  """
  def load_display_messages(conversation_id, opts \\ []) do
    limit = Keyword.get(opts, :limit, 100)
    offset = Keyword.get(opts, :offset, 0)

    DisplayMessage
    |> where([m], m.conversation_id == ^conversation_id)
    |> order_by([m], asc: m.inserted_at)
    |> limit(^limit)
    |> offset(^offset)
    |> Repo.all()
  end

  #
  # Content Type Helper Functions
  # NOTE: All helper functions create content maps with STRING keys (not atoms)
  # because Ecto :map type (JSONB) stores keys as strings
  #

  @doc """
  Appends a text message to the conversation.

  ## Parameters

    * `conversation_id` - The conversation ID
    * `message_type` - The message type ("user", "assistant", "tool", "system")
    * `text` - The text content

  ## Examples

      append_text_message(convo_id, "user", "Hello!")
      append_text_message(convo_id, "assistant", "How can I help?")
  """
  def append_text_message(conversation_id, message_type, text) do
    append_display_message(conversation_id, %{
      message_type: message_type,
      content_type: "text",
      content: %{"text" => text}  # String keys!
    })
  end

  @doc """
  Appends a thinking block to the conversation.

  Thinking blocks are internal AI reasoning that should be visually
  distinguished from regular responses. Only valid for "assistant" message type.

  ## Examples

      append_thinking_message(convo_id, "Let me analyze this step by step...")
  """
  def append_thinking_message(conversation_id, thinking_text) do
    append_display_message(conversation_id, %{
      message_type: "assistant",
      content_type: "thinking",
      content: %{"text" => thinking_text}  # String keys!
    })
  end

  @doc """
  Appends an image message to the conversation.

  ## Parameters

    * `conversation_id` - The conversation ID
    * `image_url` - URL to the image
    * `opts` - Options:
      * `:message_type` - Message type (default: "assistant")
      * `:alt_text` - Alt text for the image
      * `:caption` - Caption to display

  ## Examples

      append_image_message(convo_id, "/uploads/chart.png", alt_text: "Sales Chart")
      append_image_message(convo_id, "https://example.com/image.jpg",
        message_type: "tool", caption: "Generated chart")
  """
  def append_image_message(conversation_id, image_url, opts \\ []) do
    content = %{"url" => image_url}  # String keys!
    content = if alt = opts[:alt_text], do: Map.put(content, "alt_text", alt), else: content
    content = if caption = opts[:caption], do: Map.put(content, "caption", caption), else: content

    message_type = opts[:message_type] || "assistant"

    append_display_message(conversation_id, %{
      message_type: message_type,
      content_type: "image",
      content: content
    })
  end

  @doc """
  Appends a file reference message to the conversation.

  ## Parameters

    * `conversation_id` - The conversation ID
    * `file_path` - Path to the file
    * `file_name` - Display name of the file
    * `opts` - Options:
      * `:message_type` - Message type (default: "tool")
      * `:size` - File size in bytes
      * `:mime_type` - MIME type
      * `:metadata` - Additional metadata

  ## Examples

      append_file_message(convo_id, "/tmp/report.pdf", "Q4 Report.pdf",
        size: 245760, mime_type: "application/pdf")
  """
  def append_file_message(conversation_id, file_path, file_name, opts \\ []) do
    content = %{"path" => file_path, "name" => file_name}  # String keys!
    content = if size = opts[:size], do: Map.put(content, "size", size), else: content
    content = if mime = opts[:mime_type], do: Map.put(content, "mime_type", mime), else: content

    message_type = opts[:message_type] || "tool"

    append_display_message(conversation_id, %{
      message_type: message_type,
      content_type: "file_reference",
      content: content,
      metadata: Map.get(opts, :metadata, %{})
    })
  end

  @doc """
  Appends a structured data message to the conversation.

  ## Parameters

    * `conversation_id` - The conversation ID
    * `format` - Data format ("table", "json", "list")
    * `data` - The data to display
    * `opts` - Options:
      * `:message_type` - Message type (default: "tool")
      * `:columns` - Column headers for tables
      * `:metadata` - Additional metadata

  ## Examples

      # Table format
      append_structured_data_message(convo_id, "table",
        [["North", 125000], ["South", 98000]],
        columns: ["Region", "Sales"])

      # JSON format
      append_structured_data_message(convo_id, "json",
        %{"status" => "success", "count" => 42})
  """
  def append_structured_data_message(conversation_id, format, data, opts \\ []) do
    content = %{"format" => format, "data" => data}  # String keys!
    content = if columns = opts[:columns], do: Map.put(content, "columns", columns), else: content

    message_type = opts[:message_type] || "tool"

    append_display_message(conversation_id, %{
      message_type: message_type,
      content_type: "structured_data",
      content: content,
      metadata: Map.get(opts, :metadata, %{})
    })
  end

  @doc """
  Appends a notification message to the conversation.

  ## Parameters

    * `conversation_id` - The conversation ID
    * `text` - Notification text
    * `opts` - Options:
      * `:level` - Notification level ("info", "warning", "success") (default: "info")
      * `:details` - Additional details

  ## Examples

      append_notification_message(convo_id, "Conversation was compacted",
        level: "info", details: %{"messages_removed" => 15})
  """
  def append_notification_message(conversation_id, text, opts \\ []) do
    level = opts[:level] || "info"
    content = %{"text" => text, "level" => level}  # String keys!
    content = if details = opts[:details], do: Map.put(content, "details", details), else: content

    append_display_message(conversation_id, %{
      message_type: "system",
      content_type: "notification",
      content: content
    })
  end

  @doc """
  Appends an error message to the conversation.

  ## Parameters

    * `conversation_id` - The conversation ID
    * `error_text` - Error message text
    * `opts` - Options:
      * `:message_type` - Message type (default: "tool")
      * `:code` - Error code
      * `:details` - Additional error details
      * `:metadata` - Additional metadata (e.g., tool name)

  ## Examples

      append_error_message(convo_id, "Failed to connect to database",
        code: "DB_CONNECTION_ERROR",
        details: "Connection timeout after 30s",
        metadata: %{"tool_name" => "database_query"})
  """
  def append_error_message(conversation_id, error_text, opts \\ []) do
    content = %{"text" => error_text}  # String keys!
    content = if code = opts[:code], do: Map.put(content, "code", code), else: content
    content = if details = opts[:details], do: Map.put(content, "details", details), else: content

    message_type = opts[:message_type] || "tool"

    append_display_message(conversation_id, %{
      message_type: message_type,
      content_type: "error",
      content: content,
      metadata: Map.get(opts, :metadata, %{})
    })
  end

  @doc """
  Filters messages by content type.

  ## Examples

      load_display_messages_by_type(convo_id, "thinking")
      load_display_messages_by_type(convo_id, "image", limit: 10)
  """
  def load_display_messages_by_type(conversation_id, content_type, opts \\ []) do
    limit = Keyword.get(opts, :limit, 100)
    offset = Keyword.get(opts, :offset, 0)

    from(m in DisplayMessage,
      where: m.conversation_id == ^conversation_id,
      where: m.content_type == ^content_type,
      order_by: [asc: m.inserted_at],
      limit: ^limit,
      offset: ^offset
    )
    |> Repo.all()
  end

  @doc """
  Searches message content across all types.

  Requires scope for security. Searches within all conversations
  accessible to the given scope.

  ## Examples

      search_messages(scope, "quarterly report")
  """
  def search_messages(%Scope{} = scope, search_term) do
    # Extract owner field from scope for security
    owner_id = get_owner_id(scope)

    from(m in DisplayMessage,
      join: c in Conversation, on: m.conversation_id == c.id,
      where: c.<%= @owner_field %> == ^owner_id,
      where: fragment("?::text ILIKE ?", m.content, ^"%#{search_term}%")
    )
    |> Repo.all()
  end

  #
  # Private Helpers
  #

  # TODO: Customize this based on YOUR scope struct fields
  #
  # Example implementations:
  #
  # Single-user scope:
  # defp scope_query(query, %Scope{user_id: user_id}) do
  #   from q in query, where: q.<%= @owner_field %> == ^user_id
  # end
  #
  # Multi-tenant (organization):
  # defp scope_query(query, %Scope{organization_id: org_id}) do
  #   from q in query, where: q.organization_id == ^org_id
  # end
  #
  # Team-based:
  # defp scope_query(query, %Scope{team_id: team_id}) do
  #   from q in query, where: q.team_id == ^team_id
  # end
  #
  defp scope_query(query, %Scope{} = scope) do
    # CUSTOMIZE THIS: Use your scope's actual fields
    owner_id = get_owner_id(scope)
    from q in query, where: q.<%= @owner_field %> == ^owner_id
  end

  # TODO: Customize this based on YOUR scope struct fields
  #
  # Examples:
  # defp get_owner_id(%Scope{user: user}), do: user.id
  # defp get_owner_id(%Scope{organization_id: id}), do: id
  # defp get_owner_id(%Scope{team_id: id}), do: id
  #
  defp get_owner_id(%Scope{} = _scope) do
    # CUSTOMIZE THIS: Extract the owner ID from your scope struct
    # Pattern match on your scope's specific fields above this function
    raise "Not implemented: Extract owner ID from your scope struct. " <>
          "Update this function to pattern match on your scope's fields " <>
          "(e.g., %Scope{user_id: id} -> id)"
  end
end
